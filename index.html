<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Matiasma CCTV - Ritual Final v2</title>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <style>
        :root { 
            --neon-blue: #00f2ff; 
            --gold: #ffd700; 
            --alert: #ff2222; 
            --white: #ffffff;
            --void: #010105;
        }
        body { margin: 0; overflow: hidden; background: var(--void); font-family: 'Special Elite', cursive; }
        
        /* CINESCOPE OVERLAY */
        #cctv-overlay { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), 
                        radial-gradient(circle, transparent 60%, black 100%);
            background-size: 100% 3px, 100% 100%; 
            pointer-events: none; z-index: 100; opacity: 0.6; 
        }

        /* HUD ELEMENTS */
        .hud-panel {
            position: absolute; z-index: 110; 
            background: rgba(0, 5, 10, 0.75); 
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(4px);
            transition: border-color 0.3s, color 0.3s;
        }

        #ui-top-left { top: 20px; left: 20px; width: 220px; }
        #ui-bottom-left { bottom: 20px; left: 20px; width: 300px; height: 120px; display: flex; flex-direction: column-reverse; overflow: hidden; font-size: 11px; border-top: 2px solid var(--neon-blue); }
        #ui-bottom-right { bottom: 20px; right: 20px; width: 250px; text-align: left; }

        .label { font-size: 10px; letter-spacing: 2px; opacity: 0.7; margin-bottom: 5px; }
        .big-text { font-size: 18px; font-weight: bold; }
        
        .instruction-row { display: flex; align-items: center; margin-bottom: 8px; color: #fff; }
        .icon { width: 24px; height: 24px; margin-right: 10px; fill: var(--neon-blue); }
        .instruction-text { font-size: 13px; line-height: 1.2; }
        
        .log-entry { margin-top: 2px; opacity: 0.8; }
        .log-entry::before { content: "> "; color: var(--gold); }

        /* FLOATING WHISPERS */
        .whisper { 
            position: absolute; font-size: 14px; color: var(--alert); 
            pointer-events: none; z-index: 50; 
            font-weight: bold; text-transform: uppercase; 
            white-space: nowrap;
            /* Removed glow/shadow for clarity */
            text-shadow: none; 
            opacity: 0; /* Start hidden */
        }

        #input_video { display: none; }
        
        /* STATE CLASSES */
        .mode-cursed { color: var(--alert) !important; border-color: var(--alert) !important; }
        .mode-cursed .icon { fill: var(--alert) !important; }
        
        .mode-cleanse { color: var(--white) !important; border-color: var(--white) !important; }
        .mode-cleanse .icon { fill: var(--white) !important; }
    </style>
</head>
<body>

    <div id="cctv-overlay"></div>
    
    <div id="ui-top-left" class="hud-panel">
        <div class="label">SYSTEM_STATUS</div>
        <div id="status-text" class="big-text">OBSERVING</div>
    </div>

    <div id="ui-bottom-right" class="hud-panel">
        <div class="label">RITUAL PROTOCOLS</div>
        
        <div class="instruction-row">
            <svg class="icon" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4M13,6H11V11H6V13H11V18H13V13H18V11H13V6Z" /></svg> <div class="instruction-text">OPEN PALM (MOUTZA)<br>TO DISPERSE</div>
        </div>

        <div class="instruction-row">
             <svg class="icon" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8A4,4 0 0,0 8,12Z" /></svg> <div class="instruction-text">PINCH FINGERS<br>TO CURSE</div>
        </div>

        <div class="instruction-row">
            <svg class="icon" viewBox="0 0 24 24"><path d="M12,2C17.5,2 22,6.5 22,12C22,17.5 17.5,22 12,22C6.5,22 2,17.5 2,12C2,6.5 6.5,2 12,2M12,4C7.58,4 4,7.58 4,12C4,16.42 7.58,20 12,20C16.42,20 20,16.42 20,12C20,7.58 16.42,4 12,4M11,7H13V15H11V7M11,17H13V19H11V17Z" /></svg> <div class="instruction-text">MOVE HAND<br>TO ROTATE</div>
        </div>
    </div>

    <div id="ui-bottom-left" class="hud-panel" id="console-log"></div>
    <div id="text-container"></div>
    <video id="input_video" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const EYE_PARTICLE_COUNT = 40000;
        const SKY_PARTICLE_COUNT = 1500;
        const CURSE_WORDS = ["KAKO MATI", "BASKANIA", "ENVY", "JEALOUSY", "GLOSSOFAGIA", "PHTHONOS", "MALICE", "HATE"];
        const STATE = { IDLE: 0, CURSED: 1, CLEANSE: 2 };
        
        // --- GLOBALS ---
        let scene, camera, renderer;
        let eyeSystem, skySystem;
        let eyePos, eyeCol, eyeBasePos, eyeBaseCol, eyeExplosionDir; 
        let currentState = STATE.IDLE;
        let whispers = []; // Array of {el, x, y, z, velocity}
        
        // --- ANIMATION VARS ---
        let targetRotation = { x: 0, y: 0 }; 
        let curseFactor = 0; 
        let cleanseFactor = 0;
        let randomGlitch = 0; 

        function log(msg) {
            const container = document.getElementById('ui-bottom-left');
            const d = document.createElement('div');
            d.className = 'log-entry';
            d.innerText = msg;
            container.prepend(d);
            if(container.children.length > 6) container.removeChild(container.lastChild);
        }

        // --- ICONS UPDATE ---
        // Helper to update SVG paths if needed, or just rely on CSS fill change
        
        function getGlowSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x010105, 0.001); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            createSky();
            createEye();
            initWhispers(); // Setup container
            animate();
            log("SYSTEM_ONLINE: WAITING_FOR_INPUT");
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createSky() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<SKY_PARTICLE_COUNT; i++) {
                pos.push((Math.random()-0.5) * 1200); 
                pos.push((Math.random()-0.5) * 800); 
                pos.push((Math.random()-0.5) * 600 - 200); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 4, map: getGlowSprite(), transparent: true, opacity: 0.4,
                color: 0xaaccff, blending: THREE.AdditiveBlending, depthWrite: false
            });
            skySystem = new THREE.Points(geo, mat);
            scene.add(skySystem);
        }

        function createEye() {
            const geo = new THREE.BufferGeometry();
            eyePos = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeBasePos = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeExplosionDir = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeCol = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeBaseCol = new Float32Array(EYE_PARTICLE_COUNT * 3);

            const cPupil = new THREE.Color(0x000000); 
            const cTurquoise = new THREE.Color(0x00E0FF); 
            const cWhite = new THREE.Color(0xEEFFFF); 
            const cDeepBlue = new THREE.Color(0x0022AA); 

            for (let i = 0; i < EYE_PARTICLE_COUNT; i++) {
                const idx = i * 3;
                let r = Math.random() * 60; 
                let theta = Math.random() * Math.PI * 2;
                let thickness = Math.sqrt(60*60 - r*r) * 0.4;
                let z = (Math.random() - 0.5) * thickness;
                let x = r * Math.cos(theta);
                let y = r * Math.sin(theta);

                eyePos[idx] = x; eyePos[idx+1] = y; eyePos[idx+2] = z;
                eyeBasePos[idx] = x; eyeBasePos[idx+1] = y; eyeBasePos[idx+2] = z;

                let exPhi = Math.acos(2 * Math.random() - 1);
                let exTheta = Math.random() * 2 * Math.PI;
                eyeExplosionDir[idx] = Math.sin(exPhi) * Math.cos(exTheta);
                eyeExplosionDir[idx+1] = Math.sin(exPhi) * Math.sin(exTheta);
                eyeExplosionDir[idx+2] = Math.cos(exPhi);

                let c = new THREE.Color();
                if (r < 12) c.copy(cPupil);
                else if (r < 28) {
                    c.lerpColors(cPupil, cTurquoise, (r-12)/5); 
                    if(r > 15) c.copy(cTurquoise);
                } else if (r < 42) {
                    c.lerpColors(cTurquoise, cWhite, (r-28)/5);
                    if(r > 32) c.copy(cWhite);
                } else {
                    c.lerpColors(cWhite, cDeepBlue, (r-42)/8);
                    if(r > 48) c.copy(cDeepBlue);
                }
                c.offsetHSL(0, 0, (Math.random()-0.5)*0.1);

                eyeCol[idx] = c.r; eyeCol[idx+1] = c.g; eyeCol[idx+2] = c.b;
                eyeBaseCol[idx] = c.r; eyeBaseCol[idx+1] = c.g; eyeBaseCol[idx+2] = c.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(eyePos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(eyeCol, 3));
            
            eyeSystem = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.9, vertexColors: true, transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending, depthWrite: false
            }));
            scene.add(eyeSystem);
        }

        // --- TEXT EMISSION LOGIC ---
        function initWhispers() {
            // Pre-create DOM elements but keep them inactive
            const container = document.getElementById('text-container');
            for(let i=0; i<20; i++) {
                const el = document.createElement('div');
                el.className = 'whisper';
                el.innerText = CURSE_WORDS[Math.floor(Math.random() * CURSE_WORDS.length)];
                container.appendChild(el);
                
                // State: inactive (-1) or active timestamp
                whispers.push({
                    el: el,
                    active: false,
                    pos: new THREE.Vector3(),
                    dir: new THREE.Vector3()
                });
            }
        }

        function spawnWhisper() {
            // Find an inactive whisper
            const w = whispers.find(x => !x.active);
            if(!w) return;

            // Reset to Center (Pupil)
            w.active = true;
            w.pos.set(0, 0, 0); 
            
            // Random Direction outwards (towards camera + spread)
            w.dir.set(
                (Math.random()-0.5) * 1, // X Spread
                (Math.random()-0.5) * 0.5, // Y Spread
                0.5 + Math.random() * 0.5  // Z Speed (Forward)
            ).normalize();
            
            // Random Word
            w.el.innerText = CURSE_WORDS[Math.floor(Math.random() * CURSE_WORDS.length)];
        }

        function updateWhispers(dt) {
            // Spawn new ones periodically if Cursed or Idle
            // If Cleansing, don't spawn
            if (currentState !== STATE.CLEANSE && Math.random() < 0.05) {
                spawnWhisper();
            }

            whispers.forEach(w => {
                if(!w.active) return;

                // Move
                const speed = 10 * dt; // Units per second
                w.pos.addScaledVector(w.dir, speed);

                // Project
                // We need to apply the EYE rotation to the position so they seem to come from the object
                const worldPos = w.pos.clone().applyEuler(eyeSystem.rotation);
                
                worldPos.project(camera);

                // Visibility check
                // If behind camera or too far, reset
                const dist = w.pos.length();
                if(worldPos.z > 1 || dist > 150) {
                    w.active = false;
                    w.el.style.opacity = 0;
                    return;
                }

                // Screen Coords
                const sx = (worldPos.x * .5 + .5) * window.innerWidth;
                const sy = (-(worldPos.y * .5) + .5) * window.innerHeight;
                w.el.style.transform = `translate(${sx}px, ${sy}px)`;
                
                // Opacity Logic
                // Fade in near center, fade out near edge
                let op = Math.min(1, dist / 20); // Fade in
                if (dist > 100) op *= (1 - (dist-100)/50); // Fade out

                // If Cleansing, hide rapidly
                if (cleanseFactor > 0.1) op = 0;

                w.el.style.opacity = op;
            });
        }

        function updateStatusUI() {
            const st = document.getElementById('status-text');
            const box = document.getElementById('ui-top-left');
            const icons = document.querySelectorAll('.icon');
            
            st.classList.remove('mode-cursed', 'mode-cleanse');
            box.classList.remove('mode-cursed', 'mode-cleanse');
            icons.forEach(i => i.style.fill = 'var(--neon-blue)'); // Reset

            if(currentState === STATE.CURSED) {
                st.innerText = "MALICE DETECTED";
                st.classList.add('mode-cursed');
                box.classList.add('mode-cursed');
                icons.forEach(i => i.style.fill = 'var(--alert)');
            } else if (currentState === STATE.CLEANSE) {
                st.innerText = "DISPERSING EVIL";
                st.classList.add('mode-cleanse');
                box.classList.add('mode-cleanse');
                icons.forEach(i => i.style.fill = 'var(--white)');
            } else {
                st.innerText = "OBSERVING";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const dt = 0.016; // Approx delta

            // --- ANIMATION CONTROLLERS ---
            const targetCleanse = (currentState === STATE.CLEANSE) ? 1.0 : 0.0;
            const targetCurse = (currentState === STATE.CURSED) ? 1.0 : 0.0;
            
            cleanseFactor += (targetCleanse - cleanseFactor) * 0.2; 
            curseFactor += (targetCurse - curseFactor) * 0.2;

            if (Math.random() > 0.99) randomGlitch = 1.0;
            randomGlitch *= 0.9; 

            // --- ROTATION LOGIC ---
            let lookX = targetRotation.x;
            let lookY = targetRotation.y;

            if (currentState === STATE.IDLE) {
                lookX += Math.sin(time * 0.5) * 0.3; 
                lookY += Math.cos(time * 0.34) * 0.2;
            }

            eyeSystem.rotation.y += (lookX - eyeSystem.rotation.y) * 0.05;
            eyeSystem.rotation.x += (lookY - eyeSystem.rotation.x) * 0.05;
            
            skySystem.rotation.y = eyeSystem.rotation.y * 0.1;
            skySystem.rotation.x = eyeSystem.rotation.x * 0.1;

            // --- PARTICLE UPDATE ---
            const positions = eyeSystem.geometry.attributes.position.array;
            const colors = eyeSystem.geometry.attributes.color.array;

            for(let i=0; i<EYE_PARTICLE_COUNT; i++) {
                const idx = i*3;
                let tx = eyeBasePos[idx];
                let ty = eyeBasePos[idx+1];
                let tz = eyeBasePos[idx+2];
                const r = Math.sqrt(tx*tx + ty*ty);

                // Idle Breath
                const breath = (1 + Math.sin(time * 1.5 + r*0.1) * 0.02);
                tx *= breath; ty *= breath; tz *= breath;

                // Curse Pinch
                if(curseFactor > 0.01) {
                    const squeeze = 1.0 - (curseFactor * 0.2);
                    tx *= squeeze; ty *= squeeze;
                    tx += (Math.random()-0.5) * curseFactor * 2;
                    ty += (Math.random()-0.5) * curseFactor * 2;
                }

                // Cleanse Explosion
                if(cleanseFactor > 0.01) {
                    const blast = cleanseFactor * 100; 
                    tx += eyeExplosionDir[idx] * blast;
                    ty += eyeExplosionDir[idx+1] * blast;
                    tz += eyeExplosionDir[idx+2] * blast;
                }

                positions[idx] += (tx - positions[idx]) * 0.3;
                positions[idx+1] += (ty - positions[idx+1]) * 0.3;
                positions[idx+2] += (tz - positions[idx+2]) * 0.3;

                // Colors
                let rVal = eyeBaseCol[idx];
                let gVal = eyeBaseCol[idx+1];
                let bVal = eyeBaseCol[idx+2];

                const isPupil = r < 12;
                let redMix = 0;
                if (isPupil) redMix = Math.max(curseFactor, randomGlitch);

                if (redMix > 0.01) {
                    rVal = rVal * (1-redMix) + (1.0 * redMix);
                    gVal = gVal * (1-redMix);
                    bVal = bVal * (1-redMix);
                }
                
                colors[idx] = rVal; colors[idx+1] = gVal; colors[idx+2] = bVal;
            }

            eyeSystem.geometry.attributes.position.needsUpdate = true;
            eyeSystem.geometry.attributes.color.needsUpdate = true;
            skySystem.material.opacity = 0.4 + Math.sin(time * 0.5) * 0.1;

            updateWhispers(dt);
            renderer.render(scene, camera);
        }

        // --- MEDIAPIPE ---
        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if(currentState !== STATE.IDLE) {
                    currentState = STATE.IDLE;
                    updateStatusUI();
                }
                targetRotation.x *= 0.9;
                targetRotation.y *= 0.9;
                return;
            }

            let isPinching = false;
            let isMoutza = false;
            let avgX = 0, avgY = 0;

            results.multiHandLandmarks.forEach((landmarks) => {
                const handX = (landmarks[9].x - 0.5) * -2; 
                const handY = (landmarks[9].y - 0.5) * -2;
                avgX += handX; avgY += handY;

                // 1. Pinch Detection (Index Tip to Thumb Tip)
                const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                
                // 2. Moutza Detection (Spread Check)
                // Distance between Index Tip (8) and Pinky Tip (20)
                const spreadDist = Math.hypot(landmarks[8].x - landmarks[20].x, landmarks[8].y - landmarks[20].y);
                
                // Also check if fingers are extended (Tip y < PIP y usually means up, but rotation matters)
                // Simplified: Just check wide spread + Thumb-Index distance
                const thumbIndexDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);

                // Conditions
                if (spreadDist > 0.25 && thumbIndexDist > 0.15) {
                    isMoutza = true; 
                } else if (pinchDist < 0.05) {
                    isPinching = true;
                }
            });

            avgX /= results.multiHandLandmarks.length;
            avgY /= results.multiHandLandmarks.length;

            targetRotation.x = avgX * 1.5; 
            targetRotation.y = avgY * 0.8;

            let newState = currentState;
            if (isMoutza) newState = STATE.CLEANSE;
            else if (isPinching) newState = STATE.CURSED;
            else newState = STATE.IDLE;

            if(newState !== currentState) {
                currentState = newState;
                updateStatusUI();
                if(newState === STATE.CLEANSE) log("MOUTZA_DETECTED: CLEANSE_INIT");
                if(newState === STATE.CURSED) log("MALICIOUS_GESTURE_DETECTED");
            }
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cameraFeed.start();

        init();
    </script>
</body>
</html>
