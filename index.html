<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Matiasma CCTV v4.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root { 
            --neon-blue: #00f2ff; --gold: #ffd700; --alert: #ff2222; 
            --white: #ffffff; --void: #020213;
        }
        body { margin: 0; overflow: hidden; background: var(--void); font-family: 'Special Elite', cursive; }
        
        #cctv-overlay { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: radial-gradient(circle, transparent 60%, black 100%);
            pointer-events: none; z-index: 100; opacity: 0.6; 
        }

        #curse-pulse {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 20%, rgba(255, 0, 0, 0.5) 100%);
            opacity: 0; z-index: 90; pointer-events: none; transition: opacity 0.1s;
        }

        .hud-panel {
            position: absolute; z-index: 110; background: rgba(0, 5, 10, 0.82); 
            border: 1px solid var(--neon-blue); color: var(--neon-blue);
            padding: 12px; backdrop-filter: blur(6px);
            box-shadow: inset 0 0 15px rgba(0, 242, 255, 0.3);
            transition: all 0.3s ease;
            pointer-events: none; /* Let clicks pass to the 3D scene */
        }

        /* Responsive Positioning */
        #ui-top-left { top: 15px; left: 15px; width: auto; max-width: 200px; }
        #ui-bottom-right { bottom: 15px; right: 15px; width: auto; max-width: 240px; }
        #ui-bottom-left { 
            bottom: 15px; left: 15px; width: 300px; height: 140px; 
            display: flex; flex-direction: column-reverse; overflow: hidden; 
            border-top: 2px solid var(--neon-blue); 
        }

        /* Mobile Adjustments (Phones) */
        @media (max-width: 600px) {
            #ui-top-left { top: 10px; left: 10px; padding: 8px; }
            #ui-bottom-right { bottom: 10px; right: 10px; max-width: 160px; font-size: 10px; }
            #ui-bottom-left { bottom: 10px; left: 10px; width: 160px; height: 100px; }
            .material-icons { font-size: 18px !important; margin-right: 5px !important; }
            #status-text { font-size: 14px !important; }
            .log-curse { font-size: 12px !important; }
        }

        /* Tablet Adjustments */
        @media (min-width: 601px) and (max-width: 1024px) {
            #ui-bottom-left { width: 250px; }
            #ui-bottom-right { max-width: 200px; }
        }

        .mode-cursed { 
            border-color: var(--alert) !important; color: var(--alert) !important; 
            box-shadow: inset 0 0 25px rgba(255, 34, 34, 0.6) !important;
        }
        .mode-protect { 
            border-color: var(--gold) !important; color: var(--gold) !important; 
            box-shadow: inset 0 0 25px rgba(255, 215, 0, 0.4) !important;
        }
        .mode-mirror { 
            border-color: var(--white) !important; color: var(--white) !important; 
            box-shadow: inset 0 0 25px rgba(255, 255, 255, 0.4) !important;
        }

        .instruction-row { display: flex; align-items: center; margin-bottom: 6px; color: rgba(255,255,255,0.2); transition: 0.3s; }
        .instruction-row.active { color: #fff; text-shadow: 0 0 15px var(--neon-blue); }
        .instruction-row.active .material-icons { color: var(--neon-blue); transform: scale(1.2); }
        
        #inst-1.active .material-icons { color: var(--alert) !important; }
        #inst-4.active .material-icons { color: var(--gold) !important; }
        
        .material-icons { font-size: 22px; margin-right: 8px; color: inherit; transition: 0.3s; }
        
        .log-entry { margin-top: 3px; padding: 2px 0; border-bottom: 1px solid rgba(0,242,255,0.1); font-size: 10px; }
        .log-curse { color: var(--alert); font-size: 14px; font-weight: bold; text-shadow: 0 0 8px var(--alert); }

        #input_video { display: none; }
    </style>
</head>
<body>

    <div id="cctv-overlay"></div>
    <div id="curse-pulse"></div>

    <div id="ui-top-left" class="hud-panel">
        <div style="font-size:10px; opacity:0.7; letter-spacing: 1px;">M_SYS.LINK</div>
        <div id="status-text" style="font-size:16px; font-weight:bold">SCANNING...</div>
    </div>

    <div id="ui-bottom-right" class="hud-panel">
        <div class="instruction-row" id="inst-4"><span class="material-icons">thumb_up</span>EYES 14</div>
        <div class="instruction-row" id="inst-2"><span class="material-icons">pan_tool</span>CLEANSE</div>
        <div class="instruction-row" id="inst-3"><span class="material-icons">back_hand</span>MIRROR</div>
        <div class="instruction-row" id="inst-1"><span class="material-icons">pinch</span>CURSE</div>
    </div>

    <div id="ui-bottom-left" class="hud-panel"></div>
    <video id="input_video" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>

    <script type="module">
        import * as THREE from 'three';

        const STATE = { IDLE: 0, CURSED: 1, CLEANSE: 2, MIRROR: 3, PROTECT: 4 };
        const CURSE_WORDS = ["FTOU FTOU!", "SO LUCKY!", "MUST BE NICE", "GLOWING!", "FORTUNE"];
        const SKY_PARTICLE_COUNT = 1200;

        let scene, camera, renderer, eyeSystem, skySystem, mirrorObj;
        let currentState = STATE.IDLE;
        let eyePos, eyeCol, eyeBasePos, eyeBaseCol, subEyeOffsets = [], eyeExplosionDir;
        let curseFactor = 0, cleanseFactor = 0, mirrorFactor = 0, protectFactor = 0;
        let targetRotation = { x: 0, y: 0 }, subEyeCenters = [];

        function log(msg, isCurse = false) {
            const container = document.getElementById('ui-bottom-left');
            const d = document.createElement('div');
            d.className = isCurse ? 'log-entry log-curse' : 'log-entry';
            d.innerHTML = isCurse ? `>> ${msg}` : `> ${msg}`;
            container.prepend(d);
            if(container.children.length > 5) container.removeChild(container.lastChild);
        }
      
        function getGlowSprite() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32); return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020213, 0.002);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 150;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for mobile performance
            document.body.appendChild(renderer.domElement);

            for(let i=0; i<14; i++) subEyeCenters.push(new THREE.Vector3((Math.random()-0.5)*180, (Math.random()-0.5)*120, (Math.random()-0.5)*50));
            
            createSky(); createEye(); createMirror();
            
            window.addEventListener('resize', onWindowResize);
            animate();
            log("Matiasma CCTV Linked");
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createSky() {
            const geo = new THREE.BufferGeometry(); const pos = [];
            for(let i=0; i<SKY_PARTICLE_COUNT; i++) pos.push((Math.random()-0.5)*1200, (Math.random()-0.5)*800, (Math.random()-0.5)*600-200);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            skySystem = new THREE.Points(geo, new THREE.PointsMaterial({ size: 3, map: getGlowSprite(), transparent: true, opacity: 0.3, color: 0xaaccff, blending: THREE.AdditiveBlending, depthWrite: false }));
            scene.add(skySystem);
        }

        function createMirror() {
            const shape = new THREE.Shape();
            const w = 25, h = 40;
            shape.moveTo(-w, -h); shape.lineTo(w, -h); shape.lineTo(w, h/2);
            shape.absarc(0, h/2, w, 0, Math.PI, false); shape.lineTo(-w, -h);
            const geometry = new THREE.ExtrudeGeometry(shape, { depth: 3, bevelEnabled: true });
            const material = new THREE.MeshPhongMaterial({ color: 0x999999, emissive: 0x00ffff, transparent: true, opacity: 0 });
            mirrorObj = new THREE.Mesh(geometry, material);
            mirrorObj.rotation.x = Math.PI; scene.add(mirrorObj);
            scene.add(new THREE.PointLight(0xffffff, 1, 500));
        }

        function createEye() {
            const geo = new THREE.BufferGeometry();
            const count = 18000; // Slightly reduced for mobile performance
            eyePos = new Float32Array(count * 3); eyeBasePos = new Float32Array(count * 3);
            eyeCol = new Float32Array(count * 3); eyeBaseCol = new Float32Array(count * 3);
            eyeExplosionDir = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const idx = i * 3; subEyeOffsets[i] = i % 14;
                let r = Math.random() * 60, theta = Math.random() * Math.PI * 2;
                let tx = r * Math.cos(theta), ty = r * Math.sin(theta), tz = (Math.random()-0.5) * (Math.sqrt(3600-r*r)*0.4);
                eyePos[idx] = eyeBasePos[idx] = tx; eyePos[idx+1] = eyeBasePos[idx+1] = ty; eyePos[idx+2] = eyeBasePos[idx+2] = tz;
                
                let exPhi = Math.acos(2*Math.random()-1), exTheta = Math.random()*2*Math.PI;
                eyeExplosionDir[idx] = Math.sin(exPhi)*Math.cos(exTheta); eyeExplosionDir[idx+1] = Math.sin(exPhi)*Math.sin(exTheta); eyeExplosionDir[idx+2] = Math.cos(exPhi);
                
                let c = new THREE.Color();
                if (r < 11) c.set(0x000000); else if (r < 26) c.set(0x00ccff); else if (r < 40) c.set(0xeeffff); else c.set(0x001188);
                eyeCol[idx] = eyeBaseCol[idx] = c.r; eyeCol[idx+1] = eyeBaseCol[idx+1] = c.g; eyeCol[idx+2] = eyeBaseCol[idx+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(eyePos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(eyeCol, 3));
            eyeSystem = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.9, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }));
            scene.add(eyeSystem);
        }

        function updateUI() {
            const panels = document.querySelectorAll('.hud-panel');
            const status = document.getElementById('status-text');
            panels.forEach(p => p.classList.remove('mode-cursed', 'mode-protect', 'mode-mirror'));

            if(currentState === STATE.CURSED) panels.forEach(p => p.classList.add('mode-cursed'));
            else if(currentState === STATE.PROTECT) panels.forEach(p => p.classList.add('mode-protect'));
            else if(currentState === STATE.MIRROR) panels.forEach(p => p.classList.add('mode-mirror'));

            status.innerText = ["OBSERVING", "CURSE DETECTED", "CLEANSING...", "REFLECTING", "PROTECTED"][currentState];
            document.querySelectorAll('.instruction-row').forEach(r => r.classList.remove('active'));
            if(currentState !== STATE.IDLE) document.getElementById(`inst-${currentState}`).classList.add('active');
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            const idlePulse = 1 + Math.sin(time * 2.5) * 0.04;
            curseFactor += ((currentState === STATE.CURSED ? 1 : 0) - curseFactor) * 0.15;
            cleanseFactor += ((currentState === STATE.CLEANSE ? 1 : 0) - cleanseFactor) * 0.1;
            mirrorFactor += ((currentState === STATE.MIRROR ? 1 : 0) - mirrorFactor) * 0.1;
            protectFactor += ((currentState === STATE.PROTECT ? 1 : 0) - protectFactor) * 0.05;

            document.getElementById('curse-pulse').style.opacity = curseFactor * (0.3 + Math.sin(time*15)*0.3);

            if (currentState === STATE.IDLE) {
                eyeSystem.rotation.y += (Math.sin(time * 0.5) * 0.8 - eyeSystem.rotation.y) * 0.02;
                eyeSystem.rotation.x += (Math.cos(time * 0.3) * 0.3 - eyeSystem.rotation.x) * 0.02;
            } else {
                eyeSystem.rotation.y += (targetRotation.x - eyeSystem.rotation.y) * 0.1;
                eyeSystem.rotation.x += (targetRotation.y - eyeSystem.rotation.x) * 0.1;
            }

            if(mirrorFactor > 0.01) {
                mirrorObj.visible = true; mirrorObj.material.opacity = mirrorFactor * 0.7;
                mirrorObj.scale.set(mirrorFactor, mirrorFactor, mirrorFactor);
                mirrorObj.position.set(targetRotation.x*30, targetRotation.y*30, 40);
            } else mirrorObj.visible = false;

            const pos = eyeSystem.geometry.attributes.position.array;
            const col = eyeSystem.geometry.attributes.color.array;
            for(let i=0; i<18000; i++) {
                const idx = i*3; 
                let tx = eyeBasePos[idx] * (currentState === STATE.IDLE ? idlePulse : 1);
                let ty = eyeBasePos[idx+1] * (currentState === STATE.IDLE ? idlePulse : 1);
                let tz = eyeBasePos[idx+2];
                const r = Math.sqrt(tx*tx + ty*ty);

                if(curseFactor > 0.01) {
                    const wave = Math.sin(r * 0.3 - time * 10) * 5 * curseFactor;
                    tx += (tx/r||0) * wave; ty += (ty/r||0) * wave;
                }
                if(cleanseFactor > 0.01) {
                    tx += eyeExplosionDir[idx] * cleanseFactor * 140;
                    ty += eyeExplosionDir[idx+1] * cleanseFactor * 140;
                    tz += eyeExplosionDir[idx+2] * cleanseFactor * 140;
                }
                if(protectFactor > 0.01) {
                    const c = subEyeCenters[subEyeOffsets[i]];
                    tx = tx*(1-protectFactor) + (c.x + tx*0.15)*protectFactor;
                    ty = ty*(1-protectFactor) + (c.y + ty*0.15)*protectFactor;
                }
                pos[idx] += (tx - pos[idx]) * 0.15; pos[idx+1] += (ty - pos[idx+1]) * 0.15; pos[idx+2] += (tz - pos[idx+2]) * 0.15;
                
                if (r < 11) {
                    const blink = currentState === STATE.CURSED ? (Math.random() > 0.4 ? 1 : 0) : (Math.sin(time*5) > 0.9 ? 0.7 : 0);
                    col[idx] = blink; col[idx+1] = 0; col[idx+2] = 0;
                }
            }
            eyeSystem.geometry.attributes.position.needsUpdate = true;
            eyeSystem.geometry.attributes.color.needsUpdate = true;

            if(currentState === STATE.CURSED && Math.random() < 0.05) log(CURSE_WORDS[Math.floor(Math.random()*CURSE_WORDS.length)], true);

            renderer.render(scene, camera);
        }

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) { 
                if(currentState !== STATE.IDLE) { currentState = STATE.IDLE; updateUI(); }
                return; 
            }
            const lm = results.multiHandLandmarks[0];
            targetRotation.x = (lm[9].x - 0.5) * -2.5; targetRotation.y = (lm[9].y - 0.5) * -1.5;
            
            const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y), spread = Math.hypot(lm[8].x-lm[20].x, lm[8].y-lm[20].y);
            const isThumbUp = (lm[4].y < lm[3].y) && (lm[8].y > lm[5].y) && (lm[12].y > lm[5].y);

            let ns = STATE.IDLE;
            if(isThumbUp) ns = STATE.PROTECT;
            else if(pinch < 0.05) ns = STATE.CURSED;
            else if(spread > 0.25) ns = STATE.CLEANSE;
            else if(spread < 0.18 && Math.hypot(lm[8].x-lm[12].x, lm[8].y-lm[12].y) < 0.06) ns = STATE.MIRROR;

            if(ns !== currentState) { currentState = ns; updateUI(); }
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        hands.onResults(onResults);
        new Camera(document.getElementById('input_video'), { onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); }, width: 640, height: 480 }).start();
        init();
    </script>
</body>
</html>
