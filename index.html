<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Matiasma CCTV</title>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root { 
            --neon-blue: #00f2ff; 
            --gold: #ffd700; 
            --alert: #ff2222; 
            --white: #ffffff;
            --void: #010105;
        }
        body { margin: 0; overflow: hidden; background: var(--void); font-family: 'Special Elite', cursive; }
        
        #cctv-overlay { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), 
                        radial-gradient(circle, transparent 60%, black 100%);
            background-size: 100% 3px, 100% 100%; 
            pointer-events: none; z-index: 100; opacity: 0.6; 
        }

        .hud-panel {
            position: absolute; z-index: 110; 
            background: rgba(0, 5, 10, 0.75); 
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(4px);
            transition: all 0.3s;
        }

        #ui-top-left { top: 20px; left: 20px; width: 220px; }
        #ui-bottom-left { bottom: 20px; left: 20px; width: 300px; height: 120px; display: flex; flex-direction: column-reverse; overflow: hidden; font-size: 11px; border-top: 2px solid var(--neon-blue); }
        #ui-bottom-right { bottom: 20px; right: 20px; width: 250px; text-align: left; }

        @media (max-width: 768px) {
            #ui-top-left { top: 10px; left: 10px; width: auto; right: 10px; display: flex; justify-content: space-between; align-items: center; }
            #ui-bottom-right { bottom: 10px; right: 10px; left: 10px; width: auto; font-size: 0.9em; }
            #ui-bottom-left { display: none; }
        }

        .label { font-size: 10px; letter-spacing: 2px; opacity: 0.7; margin-bottom: 5px; }
        .big-text { font-size: 18px; font-weight: bold; }
        
        .instruction-row { display: flex; align-items: center; margin-bottom: 8px; color: #fff; }
        .material-icons { font-size: 24px; margin-right: 10px; color: var(--neon-blue); transition: color 0.3s; }
        .instruction-text { font-size: 13px; line-height: 1.2; }
        
        .log-entry { margin-top: 2px; opacity: 0.8; }
        .log-entry::before { content: "> "; color: var(--gold); }

        .whisper { 
            position: absolute; font-size: 14px; 
            pointer-events: none; z-index: 50; 
            font-weight: bold; text-transform: uppercase; 
            white-space: nowrap;
            opacity: 0;
            will-change: transform, opacity;
        }

        #input_video { display: none; }
        
        .mode-cursed { color: var(--white) !important; border-color: var(--alert) !important; box-shadow: inset 0 0 20px var(--alert);}
        .mode-cursed .material-icons { color: var(--alert) !important;  }
        
        .mode-cleanse { color: var(--white) !important; border-color: var(--white) !important; box-shadow: inset 0 0 20px var(--white); }
        .mode-cleanse .material-icons { color: var(--white) !important; }

        .mode-mirror { color: var(--white) !important; border-color: #00ff80 !important; box-shadow: inset 0 0 20px #00ff80; }
    </style>
</head>
<body>

    <div id="cctv-overlay"></div>
    
    <div id="ui-top-left" class="hud-panel">
        <div class="label">SYSTEM_STATUS</div>
        <div id="status-text" class="big-text">OBSERVING</div>
    </div>

    <div id="ui-bottom-right" class="hud-panel">
        <div class="label">RITUAL PROTOCOLS</div>
        
        <div class="instruction-row">
            <span class="material-icons">pan_tool</span>
            <div class="instruction-text">SPREAD FINGERS (MOUTZA)<br>TO DISPERSE</div>
        </div>

        <div class="instruction-row">
             <span class="material-icons">back_hand</span>
            <div class="instruction-text">FINGERS CONNECTED<br>TO MIRROR (KATHREFTAKI)</div>
        </div>

        <div class="instruction-row">
             <span class="material-icons">pinch</span>
            <div class="instruction-text">PINCH FINGERS<br>TO CURSE</div>
        </div>
    </div>

    <div id="ui-bottom-left" class="hud-panel"></div>
    <div id="text-container"></div>
    <video id="input_video" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const EYE_PARTICLE_COUNT = 20000;
        const SKY_PARTICLE_COUNT = 1500;
        const CURSE_WORDS = ["WOW, SO LUCKY AGAIN, FTOU FTOU", "LOOKING AMAZING TODAY, FTOU FTOU", "EVERYTHING FALLS INTO PLACE FOR YOU, FTOU FTOU", "ALWAYS WINNING, HUH? FTOU FTOU", "SO FORTUNATE, REALLY, FTOU FTOU", "LIVING THE DREAM, EH? FTOU FTOU", "YOU'RE GLOWING, CAREFUL NOW, FTOU FTOU", "NICE ONE, AS ALWAYS, FTOU FTOU", "MUST BE GREAT, FTOU FTOU", "HOW PERFECT FOR YOU, FTOU FTOU", "ADORABLE SUCCESS, FTOU FTOU", "YOU'RE UNSTOPPABLE, FTOU FTOU FTOU"];
        const STATE = { IDLE: 0, CURSED: 1, CLEANSE: 2, MIRROR: 3 };
        
        let scene, camera, renderer;
        let eyeSystem, skySystem, barrierGroup, barrierSolid, barrierWire;
        let eyePos, eyeCol, eyeBasePos, eyeBaseCol, eyeExplosionDir;
        let currentState = STATE.IDLE;
        let whispers = []; 
        let targetRotation = { x: 0, y: 0 }; 
        
        // Performance: Scratch variables to avoid GC inside loops
        const _v1 = new THREE.Vector3();
        const _v2 = new THREE.Vector3();
        
        let curseFactor = 0, cleanseFactor = 0, mirrorFactor = 0, randomGlitch = 0; 

        function log(msg) {
            const container = document.getElementById('ui-bottom-left');
            const d = document.createElement('div'); d.className = 'log-entry'; d.innerText = msg;
            container.prepend(d);
            if(container.children.length > 6) container.removeChild(container.lastChild);
        }

        function getGlowSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x010105, 0.001); 

            // 2. INCREASED DISTANCE
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 120; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            createSky();
            createEye();
            createBarrier(); 
            initWhispers(); 
            animate();
            log("SYSTEM_ONLINE: WAITING_FOR_INPUT");
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createBarrier() {
            // 3. OPAQUE + WIREFRAME BARRIER
            barrierGroup = new THREE.Group();
            const geo = new THREE.IcosahedronGeometry(75, 3);
            
            // Solid Layer
            const matSolid = new THREE.MeshBasicMaterial({ 
                color: 0x004422, 
                transparent: true, 
                opacity: 0, 
                side: THREE.DoubleSide 
            });
            barrierSolid = new THREE.Mesh(geo, matSolid);

            // Wireframe Layer
            const matWire = new THREE.MeshBasicMaterial({ 
                color: 0x00ff80, 
                wireframe: true, 
                transparent: true, 
                opacity: 0,
                blending: THREE.AdditiveBlending
            });
            barrierWire = new THREE.Mesh(geo, matWire);

            barrierGroup.add(barrierSolid);
            barrierGroup.add(barrierWire);
            barrierGroup.visible = false;
            scene.add(barrierGroup);
        }

        function createSky() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<SKY_PARTICLE_COUNT; i++) {
                pos.push((Math.random()-0.5) * 1200); 
                pos.push((Math.random()-0.5) * 800); 
                pos.push((Math.random()-0.5) * 600 - 200); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                size: 4, map: getGlowSprite(), transparent: true, opacity: 0.4,
                color: 0xaaccff, blending: THREE.AdditiveBlending, depthWrite: false
            });
            skySystem = new THREE.Points(geo, mat);
            scene.add(skySystem);
        }

        function createEye() {
            const geo = new THREE.BufferGeometry();
            eyePos = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeBasePos = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeExplosionDir = new Float32Array(EYE_PARTICLE_COUNT * 3); 
            eyeCol = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeBaseCol = new Float32Array(EYE_PARTICLE_COUNT * 3);

            const cPupil = new THREE.Color(0x000000); 
            const cTurquoise = new THREE.Color(0x00E0FF); 
            const cWhite = new THREE.Color(0xEEFFFF); 
            const cDeepBlue = new THREE.Color(0x0022AA); 

            for (let i = 0; i < EYE_PARTICLE_COUNT; i++) {
                const idx = i * 3;
                let r = Math.random() * 60; 
                let theta = Math.random() * Math.PI * 2;
                let thickness = Math.sqrt(60*60 - r*r) * 0.4;
                let z = (Math.random() - 0.5) * thickness;
                let x = r * Math.cos(theta);
                let y = r * Math.sin(theta);

                eyePos[idx] = eyeBasePos[idx] = x;
                eyePos[idx+1] = eyeBasePos[idx+1] = y;
                eyePos[idx+2] = eyeBasePos[idx+2] = z;

                let exPhi = Math.acos(2 * Math.random() - 1);
                let exTheta = Math.random() * 2 * Math.PI;
                eyeExplosionDir[idx] = Math.sin(exPhi) * Math.cos(exTheta);
                eyeExplosionDir[idx+1] = Math.sin(exPhi) * Math.sin(exTheta);
                eyeExplosionDir[idx+2] = Math.cos(exPhi);

                let c = new THREE.Color();
                if (r < 12) c.copy(cPupil);
                else if (r < 28) {
                    c.lerpColors(cPupil, cTurquoise, (r-12)/5); 
                    if(r > 15) c.copy(cTurquoise);
                } else if (r < 42) {
                    c.lerpColors(cTurquoise, cWhite, (r-28)/5);
                    if(r > 32) c.copy(cWhite);
                } else {
                    c.lerpColors(cWhite, cDeepBlue, (r-42)/8);
                    if(r > 48) c.copy(cDeepBlue);
                }
                eyeCol[idx] = eyeBaseCol[idx] = c.r;
                eyeCol[idx+1] = eyeBaseCol[idx+1] = c.g;
                eyeCol[idx+2] = eyeBaseCol[idx+2] = c.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(eyePos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(eyeCol, 3));
            
            eyeSystem = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.9, vertexColors: true, transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending, depthWrite: false
            }));
            scene.add(eyeSystem);
        }

        function initWhispers() {
            const container = document.getElementById('text-container');
            for(let i=0; i<15; i++) {
                const el = document.createElement('div');
                el.className = 'whisper';
                container.appendChild(el);
                whispers.push({ el: el, active: false, pos: new THREE.Vector3(), dir: new THREE.Vector3() });
            }
        }

        function spawnWhisper(time) {
            const w = whispers.find(x => !x.active);
            if(!w) return;
            w.active = true;
            w.pos.set(0, 0, 0); 
            w.dir.set((Math.random()-0.5)*1.5, (Math.random()-0.5)*0.5, 1.0).normalize();
            w.el.innerText = CURSE_WORDS[Math.floor(Math.random() * CURSE_WORDS.length)];
        }

        function updateWhispers(dt, time) {
            if (currentState !== STATE.CLEANSE && currentState !== STATE.MIRROR && Math.random() < 0.005) spawnWhisper(time);

            whispers.forEach(w => {
                if(!w.active) return;
                w.pos.addScaledVector(w.dir, 12 * dt); 
                
                // 4. PERFORMANCE: Optimized whisper positioning
                _v1.copy(w.pos).applyEuler(eyeSystem.rotation).project(camera);
                const dist = w.pos.length();

                if(_v1.z > 1 || dist > 180) { w.active = false; w.el.style.opacity = 0; return; }

                const scale = Math.min(2.5, (dist / 100) * 3);
                const colorMix = Math.min(1, dist / 80);
                const r = Math.floor(0 + (255 * colorMix));
                const g = Math.floor(242 * (1 - colorMix));
                const b = Math.floor(255 * (1 - colorMix));

                const sx = (_v1.x * .5 + .5) * window.innerWidth;
                const sy = (-(_v1.y * .5) + .5) * window.innerHeight;
                
                w.el.style.color = `rgb(${r},${g},${b})`;
                w.el.style.transform = `translate(${sx}px, ${sy}px) translate(-50%, -50%) scale(${scale})`;
                w.el.style.opacity = (cleanseFactor > 0.1 || mirrorFactor > 0.1) ? 0 : (dist < 20 ? dist/20 : 1);
            });
        }

        function updateStatusUI() {
            const st = document.getElementById('status-text');
            const box = document.getElementById('ui-top-left');
            const icons = document.querySelectorAll('.material-icons');
            
            st.className = 'big-text'; 
            box.className = 'hud-panel'; 
            icons.forEach(i => { i.style.color = 'var(--neon-blue)'; i.style.textShadow = 'none'; });

            if(currentState === STATE.CURSED) {
                st.innerText = "EVIL EYE DETECTED";
                st.classList.add('mode-cursed');
                box.classList.add('mode-cursed');
                icons[2].style.color = 'var(--alert)';
            } else if (currentState === STATE.CLEANSE) {
                st.innerText = "DISPERSING EVIL";
                st.classList.add('mode-cleanse');
                box.classList.add('mode-cleanse');
                icons[0].style.color = 'var(--white)';
            } else if (currentState === STATE.MIRROR) {
                st.innerText = "BARRIER ACTIVE";
                st.classList.add('mode-mirror');
                box.classList.add('mode-mirror');
                icons[1].style.color = '#00ff80';
            } else {
                st.innerText = "OBSERVING";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const dt = 0.016; 

            cleanseFactor += ((currentState === STATE.CLEANSE ? 1 : 0) - cleanseFactor) * 0.1; 
            curseFactor += ((currentState === STATE.CURSED ? 1 : 0) - curseFactor) * 0.15;
            mirrorFactor += ((currentState === STATE.MIRROR ? 1 : 0) - mirrorFactor) * 0.1;

            if (Math.random() > 0.99) randomGlitch = 1.0;
            randomGlitch *= 0.9; 

            eyeSystem.rotation.y += (targetRotation.x - eyeSystem.rotation.y) * 0.05;
            eyeSystem.rotation.x += (targetRotation.y - eyeSystem.rotation.x) * 0.05;
            barrierGroup.rotation.copy(eyeSystem.rotation);

            // 3. BARRIER VISUALS (Opaque + Wireframe)
            if(mirrorFactor > 0.01) {
                barrierGroup.visible = true;
                barrierSolid.material.opacity = mirrorFactor * 0.3;
                barrierWire.material.opacity = mirrorFactor * 0.8 + (Math.sin(time*10)*0.2);
                barrierGroup.scale.setScalar(1 + Math.sin(time*4)*0.02 * mirrorFactor);
            } else { barrierGroup.visible = false; }

            const positions = eyeSystem.geometry.attributes.position.array;
            const colors = eyeSystem.geometry.attributes.color.array;

            for(let i=0; i<EYE_PARTICLE_COUNT; i++) {
                const idx = i*3;
                let tx = eyeBasePos[idx];
                let ty = eyeBasePos[idx+1];
                let tz = eyeBasePos[idx+2];
                const r = Math.sqrt(tx*tx + ty*ty);

                // Idle Breath
                const breath = (1 + Math.sin(time * 1.5 + r*0.1) * 0.02);
                tx *= breath; ty *= breath; tz *= breath;

                // 1. CURSE PULSE (WAVE)
                if(curseFactor > 0.01) {
                    // radial wave: frequency 0.4, speed 12
                    const wave = Math.sin(r * 0.2 - time * 5) * 2.5 * curseFactor;
                    const angle = Math.atan2(ty, tx);
                    tx += Math.cos(angle) * wave;
                    ty += Math.sin(angle) * wave;
                }

                if(cleanseFactor > 0.01) {
                    const blast = cleanseFactor * 120; 
                    tx += eyeExplosionDir[idx] * blast;
                    ty += eyeExplosionDir[idx+1] * blast;
                    tz += eyeExplosionDir[idx+2] * blast;
                }

                positions[idx] += (tx - positions[idx]) * 0.25;
                positions[idx+1] += (ty - positions[idx+1]) * 0.25;
                positions[idx+2] += (tz - positions[idx+2]) * 0.25;

                // Color Modulation
                let rVal = eyeBaseCol[idx], gVal = eyeBaseCol[idx+1], bVal = eyeBaseCol[idx+2];
                const redMix = Math.max(curseFactor * (r < 15 ? 1 : 0), randomGlitch * (r < 12 ? 1 : 0));
                if (redMix > 0.01) {
                    rVal = rVal * (1-redMix) + redMix;
                    gVal *= (1-redMix); bVal *= (1-redMix);
                }
                colors[idx] = rVal; colors[idx+1] = gVal; colors[idx+2] = bVal;
            }

            eyeSystem.geometry.attributes.position.needsUpdate = true;
            eyeSystem.geometry.attributes.color.needsUpdate = true;
            updateWhispers(dt, time);
            renderer.render(scene, camera);
        }

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if(currentState !== STATE.IDLE) { currentState = STATE.IDLE; updateStatusUI(); }
                targetRotation.x *= 0.9; targetRotation.y *= 0.9;
                return;
            }

            const landmarks = results.multiHandLandmarks[0];
            targetRotation.x = (landmarks[9].x - 0.5) * -3; 
            targetRotation.y = (landmarks[9].y - 0.5) * -1.5;

            const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
            const spreadDist = Math.hypot(landmarks[8].x - landmarks[20].x, landmarks[8].y - landmarks[20].y);
            const neighborDist = Math.hypot(landmarks[8].x - landmarks[12].x, landmarks[8].y - landmarks[12].y);

            let newState = STATE.IDLE;
            if (pinchDist < 0.04) newState = STATE.CURSED;
            else if (spreadDist > 0.25) newState = STATE.CLEANSE;
            else if (spreadDist < 0.18 && neighborDist < 0.06) newState = STATE.MIRROR;

            if(newState !== currentState) {
                currentState = newState;
                updateStatusUI();
                if(newState === STATE.CLEANSE) log("MOUTZA: DISPERSING");
                if(newState === STATE.MIRROR) log("MIRROR: BARRIER UP");
                if(newState === STATE.CURSED) log("MALICE DETECTED");
            }
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cameraFeed.start();
        init();
    </script>
</body>
</html>
