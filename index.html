<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Matiasma CCTV - Ritual Final v4</title>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root { 
            --neon-blue: #00f2ff; 
            --gold: #ffd700; 
            --alert: #ff2222; 
            --white: #ffffff;
            --void: #010105;
        }
        body { margin: 0; overflow: hidden; background: var(--void); font-family: 'Special Elite', cursive; }
        
        #cctv-overlay { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), 
                        radial-gradient(circle, transparent 60%, black 100%);
            background-size: 100% 3px, 100% 100%; 
            pointer-events: none; z-index: 100; opacity: 0.6; 
        }

        .hud-panel {
            position: absolute; z-index: 110; 
            background: rgba(0, 5, 10, 0.75); 
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(4px);
            transition: all 0.3s;
        }

        #ui-top-left { top: 20px; left: 20px; width: 220px; }
        #ui-bottom-left { bottom: 20px; left: 20px; width: 300px; height: 120px; display: flex; flex-direction: column-reverse; overflow: hidden; font-size: 11px; border-top: 2px solid var(--neon-blue); }
        #ui-bottom-right { bottom: 20px; right: 20px; width: 250px; text-align: left; }

        @media (max-width: 768px) {
            #ui-top-left { top: 10px; left: 10px; width: auto; right: 10px; display: flex; justify-content: space-between; align-items: center; }
            #ui-bottom-right { bottom: 10px; right: 10px; left: 10px; width: auto; font-size: 0.9em; }
            #ui-bottom-left { display: none; }
        }

        .label { font-size: 10px; letter-spacing: 2px; opacity: 0.7; margin-bottom: 5px; }
        .big-text { font-size: 18px; font-weight: bold; }
        
        .instruction-row { display: flex; align-items: center; margin-bottom: 8px; color: #fff; }
        .material-icons { font-size: 24px; margin-right: 10px; color: var(--neon-blue); transition: color 0.3s; }
        .instruction-text { font-size: 13px; line-height: 1.2; }
        
        .log-entry { margin-top: 2px; opacity: 0.8; }
        .log-entry::before { content: "> "; color: var(--gold); }

        .whisper { 
            position: absolute; font-size: 14px; 
            pointer-events: none; z-index: 50; 
            font-weight: bold; text-transform: uppercase; 
            white-space: nowrap;
            opacity: 0;
            will-change: transform, opacity, color;
        }

        #input_video { display: none; }
        
        .mode-cursed { color: var(--alert) !important; border-color: var(--alert) !important; }
        .mode-cursed .material-icons { color: var(--alert) !important; }
        
        .mode-cleanse { color: var(--white) !important; border-color: var(--white) !important; }
        .mode-cleanse .material-icons { color: var(--white) !important; }

        .mode-mirror { color: var(--neon-blue) !important; border-color: var(--neon-blue) !important; box-shadow: inset 0 0 20px var(--neon-blue); }
    </style>
</head>
<body>

    <div id="cctv-overlay"></div>
    
    <div id="ui-top-left" class="hud-panel">
        <div class="label">SYSTEM_STATUS</div>
        <div id="status-text" class="big-text">OBSERVING</div>
    </div>

    <div id="ui-bottom-right" class="hud-panel">
        <div class="label">RITUAL PROTOCOLS</div>
        
        <div class="instruction-row">
            <span class="material-icons">pan_tool</span>
            <div class="instruction-text">SPREAD FINGERS (MOUTZA)<br>TO DISPERSE</div>
        </div>

        <div class="instruction-row">
             <span class="material-icons">back_hand</span>
            <div class="instruction-text">FINGERS CONNECTED<br>TO MIRROR (KATHEFTAKI)</div>
        </div>

        <div class="instruction-row">
             <span class="material-icons">pinch</span>
            <div class="instruction-text">PINCH FINGERS<br>TO CURSE</div>
        </div>
    </div>

    <div id="ui-bottom-left" class="hud-panel" id="console-log"></div>
    <div id="text-container"></div>
    <video id="input_video" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const EYE_PARTICLE_COUNT = 20000;
        const SKY_PARTICLE_COUNT = 1500;
        // 1. UPDATED CURSE WORDS
        const CURSE_WORDS = ["WOW, SO LUCKY AGAIN, FTOU FTOU", "LOOKING AMAZING TODAY, FTOU FTOU", "EVERYTHING FALLS INTO PLACE FOR YOU, FTOU FTOU", "ALWAYS WINNING, HUH? FTOU FTOU", "SO FORTUNATE, REALLY, FTOU FTOU", "LIVING THE DREAM, EH? FTOU FTOU", "YOU'RE GLOWING, CAREFUL NOW, FTOU FTOU", "NICE ONE, AS ALWAYS, FTOU FTOU", "MUST BE GREAT, FTOU FTOU", "HOW PERFECT FOR YOU, FTOU FTOU", "ADORABLE SUCCESS, FTOU FTOU", "YOU'RE UNSTOPPABLE, FTOU FTOU FTOU"];
        const STATE = { IDLE: 0, CURSED: 1, CLEANSE: 2, MIRROR: 3 };
        
        let scene, camera, renderer;
        let eyeSystem, skySystem, barrierMesh;
        let eyePos, eyeCol, eyeBasePos, eyeBaseCol, eyeExplosionDir; // Added Explosion Dir
        let currentState = STATE.IDLE;
        let whispers = []; 
        let targetRotation = { x: 0, y: 0 }; 
        let handScreenPos = { x: 0, y: 0 }; 
        
        let curseFactor = 0, cleanseFactor = 0, mirrorFactor = 0, randomGlitch = 0; 

        function log(msg) {
            const container = document.getElementById('ui-bottom-left');
            const d = document.createElement('div'); d.className = 'log-entry'; d.innerText = msg;
            container.prepend(d);
            if(container.children.length > 6) container.removeChild(container.lastChild);
        }

        function getGlowSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x010105, 0.001); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            createSky();
            createEye();
            createBarrier(); 
            initWhispers(); 
            animate();
            log("SYSTEM_ONLINE: WAITING_FOR_INPUT");
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createBarrier() {
            // 3. MORE DRAMATIC MIRROR (Subdivision 2 for hex feel)
            const geo = new THREE.IcosahedronGeometry(70, 3);
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0xFF00FF, 
                wireframe: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending // Glow effect
            });
            barrierMesh = new THREE.Mesh(geo, mat);
            barrierMesh.visible = false;
            scene.add(barrierMesh);
        }

        function createSky() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<SKY_PARTICLE_COUNT; i++) {
                pos.push((Math.random()-0.5) * 1200); 
                pos.push((Math.random()-0.5) * 800); 
                pos.push((Math.random()-0.5) * 600 - 200); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                size: 4, map: getGlowSprite(), transparent: true, opacity: 0.4,
                color: 0xaaccff, blending: THREE.AdditiveBlending, depthWrite: false
            });
            skySystem = new THREE.Points(geo, mat);
            scene.add(skySystem);
        }

        function createEye() {
            const geo = new THREE.BufferGeometry();
            eyePos = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeBasePos = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeExplosionDir = new Float32Array(EYE_PARTICLE_COUNT * 3); // 4. RESTORED EXPLOSION VECTORS
            eyeCol = new Float32Array(EYE_PARTICLE_COUNT * 3);
            eyeBaseCol = new Float32Array(EYE_PARTICLE_COUNT * 3);

            const cPupil = new THREE.Color(0x000000); 
            const cTurquoise = new THREE.Color(0x00E0FF); 
            const cWhite = new THREE.Color(0xEEFFFF); 
            const cDeepBlue = new THREE.Color(0x0022AA); 

            for (let i = 0; i < EYE_PARTICLE_COUNT; i++) {
                const idx = i * 3;
                let r = Math.random() * 60; 
                let theta = Math.random() * Math.PI * 2;
                let thickness = Math.sqrt(60*60 - r*r) * 0.4;
                let z = (Math.random() - 0.5) * thickness;
                let x = r * Math.cos(theta);
                let y = r * Math.sin(theta);

                eyePos[idx] = eyeBasePos[idx] = x;
                eyePos[idx+1] = eyeBasePos[idx+1] = y;
                eyePos[idx+2] = eyeBasePos[idx+2] = z;

                // Precompute explosion direction (Spherical)
                let exPhi = Math.acos(2 * Math.random() - 1);
                let exTheta = Math.random() * 2 * Math.PI;
                eyeExplosionDir[idx] = Math.sin(exPhi) * Math.cos(exTheta);
                eyeExplosionDir[idx+1] = Math.sin(exPhi) * Math.sin(exTheta);
                eyeExplosionDir[idx+2] = Math.cos(exPhi);

                let c = new THREE.Color();
                if (r < 12) c.copy(cPupil);
                else if (r < 28) {
                    c.lerpColors(cPupil, cTurquoise, (r-12)/5); 
                    if(r > 15) c.copy(cTurquoise);
                } else if (r < 42) {
                    c.lerpColors(cTurquoise, cWhite, (r-28)/5);
                    if(r > 32) c.copy(cWhite);
                } else {
                    c.lerpColors(cWhite, cDeepBlue, (r-42)/8);
                    if(r > 48) c.copy(cDeepBlue);
                }
                c.offsetHSL(0, 0, (Math.random()-0.5)*0.1);

                eyeCol[idx] = eyeBaseCol[idx] = c.r;
                eyeCol[idx+1] = eyeBaseCol[idx+1] = c.g;
                eyeCol[idx+2] = eyeBaseCol[idx+2] = c.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(eyePos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(eyeCol, 3));
            
            eyeSystem = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.9, vertexColors: true, transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending, depthWrite: false
            }));
            scene.add(eyeSystem);
        }

        function initWhispers() {
            const container = document.getElementById('text-container');
            for(let i=0; i<15; i++) {
                const el = document.createElement('div');
                el.className = 'whisper';
                container.appendChild(el);
                whispers.push({ el: el, active: false, pos: new THREE.Vector3(), dir: new THREE.Vector3(), spawnTime: 0 });
            }
        }

        function spawnWhisper(time) {
            const w = whispers.find(x => !x.active);
            if(!w) return;
            w.active = true;
            w.spawnTime = time;
            w.pos.set(0, 0, 0); 
            w.dir.set((Math.random()-0.5)*1.5, (Math.random()-0.5)*0.5, 1.0).normalize();
            w.el.innerText = CURSE_WORDS[Math.floor(Math.random() * CURSE_WORDS.length)];
            w.el.style.color = "var(--neon-blue)"; 
        }

        function updateWhispers(dt, time) {
            if (currentState !== STATE.CLEANSE && currentState !== STATE.MIRROR && Math.random() < 0.005) spawnWhisper(time);

            whispers.forEach(w => {
                if(!w.active) return;
                const dist = w.pos.length();
                
                // 2. SLOWER SPEED (Reduced from 30 to 8)
                w.pos.addScaledVector(w.dir, 8 * dt); 

                const worldPos = w.pos.clone().applyEuler(eyeSystem.rotation);
                worldPos.project(camera);

                if(worldPos.z > 1 || dist > 150) { w.active = false; w.el.style.opacity = 0; return; }

                // 2. GIANT TEXT SCALING (Max scale 3 instead of 1)
                const scale = Math.min(3, (dist / 100) * 3);

                const colorMix = Math.min(1, dist / 80);
                const r = Math.floor(0 + (255 * colorMix));
                const g = Math.floor(242 * (1 - colorMix));
                const b = Math.floor(255 * (1 - colorMix));
                w.el.style.color = `rgb(${r},${g},${b})`;

                const sx = (worldPos.x * .5 + .5) * window.innerWidth;
                const sy = (-(worldPos.y * .5) + .5) * window.innerHeight;
                
                w.el.style.transform = `translate(${sx}px, ${sy}px) translate(-50%, -50%) scale(${scale})`;
                
                let op = dist < 20 ? dist/20 : 1;
                if(cleanseFactor > 0.1 || mirrorFactor > 0.1) op = 0;
                w.el.style.opacity = op;
            });
        }

        function updateStatusUI() {
            const st = document.getElementById('status-text');
            const box = document.getElementById('ui-top-left');
            const icons = document.querySelectorAll('.material-icons');
            
            st.className = 'big-text'; 
            box.className = 'hud-panel'; 
            icons.forEach(i => { i.style.color = 'var(--neon-blue)'; i.style.textShadow = 'none'; });

            if(currentState === STATE.CURSED) {
                st.innerText = "MALICE DETECTED";
                st.classList.add('mode-cursed');
                box.classList.add('mode-cursed');
                icons[2].style.color = 'var(--alert)';
                icons[2].style.textShadow = '0 0 10px var(--alert)';
              
            } else if (currentState === STATE.CLEANSE) {
                st.innerText = "DISPERSING EVIL";
                st.classList.add('mode-cleanse');
                box.classList.add('mode-cleanse');
                icons[0].style.color = 'var(--white)';
                icons[0].style.textShadow = '0 0 10px white';
            } else if (currentState === STATE.MIRROR) {
                st.innerText = "BARRIER ACTIVE";
                st.classList.add('mode-mirror');
                box.classList.add('mode-mirror');
                icons[1].style.color = '#FF00FF';
                icons[1].style.textShadow = '0 0 10px #FF00FF';
            } else {
                st.innerText = "OBSERVING";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const dt = 0.016; 

            const targetCleanse = (currentState === STATE.CLEANSE) ? 1.0 : 0.0;
            const targetCurse = (currentState === STATE.CURSED) ? 1.0 : 0.0;
            const targetMirror = (currentState === STATE.MIRROR) ? 1.0 : 0.0;
            
            cleanseFactor += (targetCleanse - cleanseFactor) * 0.1; 
            curseFactor += (targetCurse - curseFactor) * 0.2;
            mirrorFactor += (targetMirror - mirrorFactor) * 0.1;

            if (Math.random() > 0.99) randomGlitch = 1.0;
            randomGlitch *= 0.9; 

            let lookX = targetRotation.x;
            let lookY = targetRotation.y;
            if (currentState === STATE.IDLE) {
                lookX += Math.sin(time * 0.5) * 0.3; 
                lookY += Math.cos(time * 0.34) * 0.2;
            }

            eyeSystem.rotation.y += (lookX - eyeSystem.rotation.y) * 0.05;
            eyeSystem.rotation.x += (lookY - eyeSystem.rotation.x) * 0.05;
            
            barrierMesh.rotation.copy(eyeSystem.rotation);
            skySystem.rotation.y = eyeSystem.rotation.y * 0.1;
            skySystem.rotation.x = eyeSystem.rotation.x * 0.1;

            // 3. DRAMATIC MIRROR VISUALS
            if(mirrorFactor > 0.01) {
                barrierMesh.visible = true;
                barrierMesh.material.opacity = mirrorFactor * 0.4 + (Math.sin(time*8)*0.1);
                barrierMesh.scale.setScalar(1 + Math.sin(time*4)*0.05 * mirrorFactor);
            } else {
                barrierMesh.visible = false;
            }

            const positions = eyeSystem.geometry.attributes.position.array;
            const colors = eyeSystem.geometry.attributes.color.array;

            for(let i=0; i<EYE_PARTICLE_COUNT; i++) {
                const idx = i*3;
                let tx = eyeBasePos[idx];
                let ty = eyeBasePos[idx+1];
                let tz = eyeBasePos[idx+2];
                
                // Idle Breath
                const r = Math.sqrt(tx*tx + ty*ty);
                const breath = (1 + Math.sin(time * 1.5 + r*0.1) * 0.02);
                tx *= breath; ty *= breath; tz *= breath;

                if(curseFactor > 0.01) {
                    const squeeze = 1.0 - (curseFactor * 0.2);
                    tx *= squeeze; ty *= squeeze;
                    tx += (Math.random()-0.5) * curseFactor * 2;
                    ty += (Math.random()-0.5) * curseFactor * 2;
                }

                // 4. RESTORED CLEANSE EXPLOSION LOGIC
                if(cleanseFactor > 0.01) {
                    const blast = cleanseFactor * 100; 
                    tx += eyeExplosionDir[idx] * blast;
                    ty += eyeExplosionDir[idx+1] * blast;
                    tz += eyeExplosionDir[idx+2] * blast;
                }

                positions[idx] += (tx - positions[idx]) * 0.3;
                positions[idx+1] += (ty - positions[idx+1]) * 0.3;
                positions[idx+2] += (tz - positions[idx+2]) * 0.3;

                // Colors
                let rVal = eyeBaseCol[idx];
                let gVal = eyeBaseCol[idx+1];
                let bVal = eyeBaseCol[idx+2];

                const isPupil = r < 12;
                let redMix = 0;
                if (isPupil) redMix = Math.max(curseFactor, randomGlitch);

                if (redMix > 0.01) {
                    rVal = rVal * (1-redMix) + (1.0 * redMix);
                    gVal = gVal * (1-redMix);
                    bVal = bVal * (1-redMix);
                }
                
                colors[idx] = rVal; colors[idx+1] = gVal; colors[idx+2] = bVal;
            }

            eyeSystem.geometry.attributes.position.needsUpdate = true;
            eyeSystem.geometry.attributes.color.needsUpdate = true;
            skySystem.material.opacity = 0.4 + Math.sin(time * 0.5) * 0.1;

            updateWhispers(dt, time);
            renderer.render(scene, camera);
        }

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if(currentState !== STATE.IDLE) {
                    currentState = STATE.IDLE;
                    updateStatusUI();
                }
                targetRotation.x *= 0.9;
                targetRotation.y *= 0.9;
                return;
            }

            let isPinching = false, isMoutza = false, isMirror = false;
            let avgX = 0, avgY = 0;

            results.multiHandLandmarks.forEach((landmarks) => {
                const handX = (landmarks[9].x - 0.5) * -2; 
                const handY = (landmarks[9].y - 0.5) * -2;
                avgX += handX; avgY += handY;

                const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                const spreadDist = Math.hypot(landmarks[8].x - landmarks[20].x, landmarks[8].y - landmarks[20].y);
                const neighborDist = Math.hypot(landmarks[8].x - landmarks[12].x, landmarks[8].y - landmarks[12].y);
                const thumbIndexDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);

                if (pinchDist < 0.05) isPinching = true;
                else if (thumbIndexDist > 0.1) {
                    if (spreadDist > 0.25) isMoutza = true;
                    else if (spreadDist < 0.20 && neighborDist < 0.06) isMirror = true;
                }
            });

            avgX /= results.multiHandLandmarks.length;
            avgY /= results.multiHandLandmarks.length;

            handScreenPos.x = avgX;
            handScreenPos.y = avgY;
            targetRotation.x = avgX * 1.5; 
            targetRotation.y = avgY * 0.8;

            let newState = currentState;
            if (isMoutza) newState = STATE.CLEANSE;
            else if (isMirror) newState = STATE.MIRROR;
            else if (isPinching) newState = STATE.CURSED;
            else newState = STATE.IDLE;

            if(newState !== currentState) {
                currentState = newState;
                updateStatusUI();
                if(newState === STATE.CLEANSE) log("MOUTZA DETECTED: DISPERSING");
                if(newState === STATE.MIRROR) log("MIRROR PROTOCOL: BARRIER UP");
                if(newState === STATE.CURSED) log("MALICIOUS GESTURE DETECTED");
            }
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cameraFeed.start();

        init();
    </script>
</body>
</html>
